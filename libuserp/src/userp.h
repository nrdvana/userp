#ifndef USERP_H
#define USERP_H

/* Userp encoder/decoder state is referenced by this struct. */
typedef struct UserpState_s UserpState_t;

/* Alloc a UserpState_t using malloc() */
extern UserpState_t *userp_new();

/* Alloc a UserpState_t using custom allocation/resize/free functions */
typedef void* (UserpAllocFn_t*)(size_t size);
typedef void* (UserpReallocFn_t*)(void* mem, size_t size);
typedef void* (UserpFreeFn_t*)(void* mem);
extern UserpState_t *userp_new_cusom_alloc(UserpAllocFn_t alloc, UserpReallocFn_t realloc, UserpFreeFn_t free);

/* Destroy and free a UserpState_t using an appropriate free() function */
extern void userp_destroy(UserpState_t *state);

/* Return the last error code generated by the library for this UserpState_t.
 * Can also return the constant symbolic name of that error, and diagnostic message
 */
extern int userp_get_last_error(UserpState_t *state, const char **errname, char *diag_buf, int *diag_buflen);

/* Userp library data describing a metadata or data block, for encoding or decoding. */
typedef struct UserpBlock_s UserpBlock_t;

#define USERP_META_BLOCK 1
#define USERP_DATA_BLOCK 3
#define USERP_MUTABLE    8
/* Create a new UserpBlock_t to parse the given data buffer */
extern UserpBlock_t *userp_parse_block(UserpState_t *state, int flags, const void *blockdata, size_t blocklen);
/* Create a new UserpBlock_t to begin writing a new block, possibly using a user-supplied buffer */
extern UserpBlock_t *userp_begin_block(UserpState_t *state, int flags, void *buffer, size_t bufferlen);
/* Destroy a block once it is no longer needed.  This can fail if the block is in use. */
extern bool userp_destroy_block(UserpBlock_t *block);

/* Declare an identifier in the given metadata block.  Useful for pre-populating the ident cache */
extern int userp_meta_declare_ident(UserpBlock_t *block, const char *name);
/* Declare a new type in the given metadata block. */
extern int userp_meta_new_type(UserpBlock_t *block, const char *name, const char *typespec, int tag_count, const char **tags);

/* Look up a type by name, optionally verifying it against a type of the same name in another meta block. */
#define userp_type_by_name(block,name) userp_type_by_name_matching(block,name,NULL)
extern int userp_type_by_name_matching(UserpBlock_t *block, const char *name, UserpBlock_t *assert_match);

/* Get the name of a type ID in the scope of the given block (data or metadata) */
extern const char* userp_meta_get_typename(UserpBlock_t *block, int type_id);
/* Get the specification for a type in the scope of the given block.
 * Can also return the type_id of each referenced type.
 * Can also return the application-specific tags.
 */
extern int userp_meta_get_typespec(UserpBlock_t *block, int type_id,
	char *spec_buf, size_t buf_len, /* buffer to receive specification string.  size must include room for NUL */
	size_t *type_id_count, const int **type_id, /* list of type IDs. */
	size_t *tag_count, const char * const **tags_buf, /* list of tags */
);

/* Block-Read API */

extern int userp_node_info(UserpBlock_t *block, int *node_type, int *seq_elems, int *seq_elem_type);
extern int userp_enter_node(UserpBlock_t *block);
extern int userp_elem_seek(UserpBlock_t *block, size_t elem_idx);
extern int userp_elem_seek_ident(UserpBlock_t *block, int ident);
extern int userp_elem_seek_name(UserpBlock_t *block, const char *ident_name);
extern int userp_exit_node(UserpBlock_t *block);

extern int userp_read_int(UserpBlock_t *block, int *node_type, int *node_value);
extern int userp_read_longlong(UserpBlock_t *block, int *node_type, long long *node_value);
extern int userp_read_float(UserpBlock_t *data, int *node_type, float *node_value);
extern int userp_read_double(UserpBlock_t *data, int *node_type, double *node_value);
extern int userp_read_data(UserpBlock_t *block, int *node_type, void *node_value, size_t *node_value_len);
extern int userp_read_nocopy(UserpBlock_t *block, int *node_type, const void **node_ptr, size_t *node_value_len);

/* Block-Write API */

extern int userp_begin_node(UserpBlock_t *block, int type_id, size_t elem_count);
extern int userp_end_node(UserpBlock_t *block);

extern int userp_write_int(UserpBlock_t *block, int type_id, int value);
extern int userp_write_longlong(UserpBlock_t *block, int type_id, long long value);
extern int userp_write_float(UserpBlock_t *block, int type_id, float value);
extern int userp_write_double(UserpBlock_t *block, int type_id, double value);
extern int userp_write_data(UserpBlock_t *block, int type_id, void *value, size_t value_len);
extern int userp_write_get_address(UserpBlock_t *block, int type_id, void **node_ptr, size_t *buf_len);
extern int userp_write_nocopy(UserpBlock_t *block, int type_id, size_t buf_len);

#endif
